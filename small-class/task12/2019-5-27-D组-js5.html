<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <link rel="icon" href="favicon.ico" type="x-icon">

    <style>
        .float {
            float: left;
        }
    </style>


    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ?
            'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : './css/reveal/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>

<body>
    <img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
    <map name="pttmap">
        <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com/" alt="" target="_blank">
    </map>
    <<div class="reveal">
        <div class="slides">
            <section>
                <h2>什么是rest风格?get 与 post的区别?application json 与form表单的区别?</h2>
                <p>分享人：顾仁鹏</p>
            </section>
            <section>
                <p>目录</p>
                <p>1.背景介绍</p>
                <p>2.知识剖析</p>
                <p>3.常见问题</p>
                <p>4.解决方案</p>
                <p>5.编码实战</p>
                <p>6.扩展思考</p>
                <p>7.参考文献</p>
                <p>8.更多讨论</p>
            </section>
            <section>
                <section>
                    <h3>1.背景介绍</h3>
                </section>
                <section>
                    <p style="text-align:left;"> REST是REpresentational State Transfer 的缩写，那它究竟意味着什么呢？
                        也许这个问题已经困惑你很久了，下面就由我给你细细分解。
                        <br />
                        从宏观上讲，REST 是一种设计网络应用时的构架风格。这种风格约束了网络应用中各个模块之间的交互，
                        从而使网络应用具有非常好的简易性，扩展性，可靠性等。</p>
                </section>

            </section>
            <section>
                <section>
                    <h3>2.知识剖析</h3>
                </section>
                <section>
                    <h3>API</h3>
                    <p style="text-align:left;">要解释什么是REST，你应该先了解什么是API（Application Programming Interface,应用程序编程接口）</p>
                    <p style="text-align:left;">
                        形象一点说就是像一个公司比如腾讯，阿里巴巴之类，他们可以提供一个API，然后我们或者一些其他的小公司可以编一个软件去跟这个接口（API）进行相连或交互。
                    </p>
                    <p style="text-align:left;">
                        举个例子，比如你可以用手机的其他软件分享内容到微信朋友圈或者新浪微博，这些软件就是与微信和微博的api进行了交互。
                    </p>
                    <p style="text-align:left;">
                        知道了API，那么就容易理解REST了。它是一种架构风格，腾讯公司或其他公司建立API时要遵守的一种规则/风格，当然也有其他规则可以用。
                    </p>
                </section>
                <section>
                    <h3>web</h3>
                    <p style="text-align:left;"> Web是分布式信息系统为超文本文件和其他对象（资源）提供访问入口。</p>
                    <p style="text-align:left;">
                        资源是Web架构的关键点,需要3个操作:<br>
                        识别(identify)，表示(represent)，交互(interact with)
                    </p>
                    <p style="text-align:left;">
                        通过这三个操作，又引出三个概念:<br>
                        1.uri（统一资源标识符包括url和urn）识别资源；<br>
                        2.representation （例如html，图片，视频等等）表示资源；<br>
                        3.通过协议（包括http，ftp等等）与资源进行交互。
                    </p>
                </section>
                <section>
                    <h3>REST</h3>
                    <p style="text-align:left; font-size: 20px">REST不是"rest"这个单词，而是Resource Representational State
                        Transfer的缩写：简单来说：就是一种组织Web平台服务的架构 分开来讲：</p>
                    <p style="text-align:left; font-size: 20px">它的特性或者说约束有以下几点:</p>
                    <p style="text-align:left; font-size: 20px">
                        1.使用客户/服务器模型。客户和服务器之间通过一个统一的接口来互相通讯。<br>
                        2.层次化的系统。在一个REST系统中，客户端并不会固定地与一个服务器打交道。<br>
                        3. 无状态。在一个REST系统中，服务端并不会保存有关客户的任何状态。也就是说，客户端自身负责用户状态的维持，并在每次发送请求时都需要提供足够的信息。<br>
                        4. 可缓存。REST系统需要能够恰当地缓存请求，以尽量减少服务端和客户端之间的信息传输，以提高性能。<br>
                        5. 统一的接口。一个REST系统需要使用一个统一的接口来完成子系统之间以及服务与用户之间的交互。这使得REST系统中的各个子系统可以独自完成演化。</p>
                </section>
                <section>
                    <h3>具体特性</h3>
                    <p style="text-align: left; font-size: 20px">
                        1.Resource：资源，即数据（网络的核心）。<br>
                        2.Representational：某种表现形式，比如用JSON，XML，JPEG等；<br>
                        3.State Transfer：状态变化。通过HTTP动词实现。<br>
                        4. REST描述的是在网络中client和server的一种交互形式；REST本身不实用，实用的是如何设计 RESTful API（REST风格的网络接口；<br>
                        5. Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心。<br>
                        6. 用HTTP协议里的动词来实现资源的添加，修改。<br>
                        7. Server和Client之间传递某资源的一个表现形式，比如用JSON，XML传输文本，或者用JPG，WebP传输图片等。<br>
                        8. 用 HTTP Status Code传递Server的状态信息。比如最常用的 200 表示成功，500 表示Server内部错误等。<br>
                        Web端不再用之前典型的PHP或JSP架构，而是改为前段渲染和附带处理简单的商务逻辑。Web端和Server只使用上述定义的API来传递数据和改变数据状态。格式一般是JSON。
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h3>3.常见问题</h3>
                </section>
                <section>
                    <h3>统一的接口有哪些</h3>
                </section>

            </section>
            <section>
                <section>
                    <h3>4.解决方案</h3>
                </section>
                <section>
                    <p style="text-align: left">
                        1.GET（SELECT）： 从服务器获取资源(一项或多项)<br>
                        2.POST（CREATE）： 在服务器新建一个资源<br>
                        3.PUT（UPDATE）： 在服务器更新资源（客户端提供改变后的完整资源）<br>
                        4.PATCH（UPDATE）： 在服务器更新资源（客户端提供改变的属性）<br>
                        5.DELETE（DELETE）：从服务器删除资源。
                    </p>
                </section>
                <section>
                    <p style="text-align: left">
                        比如：<br>
                        GET /zoos：列出所有动物园<br>
                        POST /zoos：新建一个动物园<br>
                        GET /zoos/ID：获取某个指定动物园的信息<br>
                        PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息<br>
                        PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）<br>
                        DELETE /zoos/ID：删除某个动物园<br>
                        GET /zoos/ID/animals：列出某个指定动物园的所有动物<br>
                        DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物
                    </p>
                </section>
            </section>

            <section>
                <section>
                    <h3>5.编码实战</h3>
                </section>
            </section>

            <section>
                <section>
                    <h3>6.扩展思考</h3>
                    <h4>1.get与post的区别</h4>
                    <h4>2.application json 与form表单的区别?</h4>
                </section>
                <section>
                    <p style="text-align: left">首先我们要知道GET和POST都是HTTP定义的和服务器互交的不同方法。</p>
                    <p style="text-align: left">1.语义上的不同:</p>
                    <p style="text-align: left">GET：获取指定URL上的资源，是读操作，</p>
                    <p style="text-align: left">POST：向指定资源“追加/添加”数据.</p>
                </section>
                <section>
                    <P style="text-align: left">2.对于“安全”所代表的设定。</P>
                    <p style="text-align: left;font-size: 22px">
                        根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。<br>
                        换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。这里安全的含义仅仅是指是非修改信息。<br>
                        幂等的意味着对同一URL的多个请求应该返回同样的结果
                    </p>
                    <p style="text-align: left;font-size: 22px">
                        根据HTTP规范，POST表示可能修改变服务器上的资源的请求。</p>
                    <p style="text-align: left;font-size: 22px">对于传递过程来说，指的是提交的数据不会直接在地址栏看见。
                        <br>POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。
                        上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，
                        比如：通过GET提交数据，用户名和密码将明文出现在URL上，
                        因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site
                        request forgery攻击。</p>
                </section>

                <section>
                    <p style="text-align: left;font-size: 22px">3.请求数据方法不同:</p>
                    <p style="text-align: left;font-size: 22px">
                        .GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&相连，
                        如：login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，
                        如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，
                        其中％XX中的XX为该符号以16进制表示的ASCII。HTTP协议没有对get和post做长度的限制，但是浏览器会对url长度做限制最多1024字节，所以get方法传递数据受限制。</p>
                    <p style="text-align: left;font-size: 22px">POST把提交的数据则放置在是HTTP包的包体中。如：name1=value1&name2=value2</p>
                </section>
                <section>
                    <P style="text-align: left;font-size: 22px">4.GET是幂等的，POST是非幂等的</P>
                    <P style="text-align: left;font-size: 22px">先介绍下幂等的概念：如果一个操作没有副作用，或者多次操作对资源产生的副作用相同，我们就说这个操作是幂等的.</P>
                    <p style="text-align: left;font-size: 22px">
                        get方法用户获取资源，没有副作用，所以是幂等的；post用于创建资源，是有副作用的，且副作用不同，所以post不是幂等的。（两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI）
                    </p>
                </section>
                <section>
                    <h4>2.application json 与form表单的区别?</h4>
                    <p style="text-align: left;font-size: 22px"> application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，
                        现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。
                        由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，
                        服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。angular中默认的就是这个格式</p>
                </section>
                <section>
                    <p style="text-align: left;font-size: 22px">
                        application/x-www-form-urlencoded
                        这应该是最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype 属性，
                        那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（
                        无关的请求头在本文中都省略掉了）：
                        POST http://www.example.com HTTP/1.1
                        Content-Type: application/x-www-form-urlencoded;charset=utf-8
                        title=test&sub%5B%5D=1&sub%5B%5D=2&sub%5B%5D=3
                        首先，Content-Type 被指定为 application/x-www-form-urlencoded；
                        其次，提交的数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。
                        大部分服务端语言都对这种方式有很好的支持。
                    </p>
                </section>
            </section>

            <section>
                <section>
                    <h3>7.参考文献</h3>
                </section>
                <section>
                    <p>参考一：<a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank">W3C</a>
                    </p>
                    <P>参考二：<a href="https://www.zhihu.com/question/28586791" target="_blank"> 知乎——get和post区别？ </a></P>
                    <P>参考三：<a href="http://www.cnblogs.com/Guazi-JS/archive/2010/05/05/1727966.html" target="_blank">
                            AJAX和表单提交中GET与POST的区别 </a></P>
                    <P>参考四：<a href="https://www.oschina.net/news/77354/http-get-post-different" target="_blank">
                            99%的人理解错 HTTP 中 GET 与 POST 的区别 </a></P>
                    <P>参考五：<a href="https://zhuanlan.zhihu.com/p/25028045" target="_blank"> 听说『99% 的人都理解错了 HTTP 中 GET 与
                            POST 的区别』？？ </a></P>
                    <p>参考六：<a href="http://blog.csdn.net/mm_gg_201512/article/details/72830000" target="_blank">
                            application/json 和 application/x-www-form-urlencoded的区别</a></p>
                </section>
            </section>

            <section>
                <section>
                    <h3>8.更多讨论</h3>
                </section>
            </section>
            <section>
                <h4>鸣谢</h4>
                <p>感谢大家观看</p>
                <p class="text-center">
                    <small>BY : 顾仁鹏</small>
                </p>
            </section>
        </div>
        </div>
        <div class="backgrounds">
            <div class="slide-background past" data-loaded="true" style="display: none;"></div>
            <div class="slide-background past" data-loaded="true" style="display: block;"></div>
            <div class="slide-background past" data-loaded="true" style="display: block;"></div>
            <div class="slide-background stack present" data-loaded="true" style="display: block;">
                <div class="slide-background past" data-loaded="true" style="display: block;"></div>
                <div class="slide-background present" data-loaded="true" style="display: block;"></div>
            </div>
            <div class="slide-background future" data-loaded="true" style="display: block;"></div>
            <div class="slide-background future" data-loaded="true" style="display: block;"></div>
            <div class="slide-background future" data-loaded="true" style="display: none;"></div>
            <div class="slide-background future" data-loaded="true" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background stack future" style="display: none;">
                <div class="slide-background present" style="display: none;"></div>
            </div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background stack future" style="display: none;">
                <div class="slide-background present" style="display: none;"></div>
            </div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background stack future" style="display: none;">
                <div class="slide-background present" style="display: none;"></div>
            </div>
            <div class="slide-background stack future" style="display: none;">
                <div class="slide-background present" style="display: none;"></div>
                <div class="slide-background future" style="display: none;"></div>
                <div class="slide-background future" style="display: none;"></div>
            </div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
            <div class="slide-background future" style="display: none;"></div>
        </div>
        <div class="progress" style="display: block;"><span style="width: 260.19px;"></span></div>
        <aside class="controls" style="display: block;"><button class="navigate-left enabled"
                aria-label="previous slide"></button><button class="navigate-right enabled"
                aria-label="next slide"></button><button class="navigate-up enabled"
                aria-label="above slide"></button><button class="navigate-down" aria-label="below slide"></button>
        </aside>
        <div class="slide-number" style="display: none;"></div>
        <div class="speaker-notes" data-prevent-swipe=""></div>
        <div class="pause-overlay"></div>
        <div id="aria-status-div" aria-live="polite" aria-atomic="true"
            style="position: absolute; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px);">

            语法：
            return[()[expression][]];
            可选项 expression 参数是要从函数返回的值。如果省略，则该函数不返回值。

            用 return 语句来终止一个函数的执行，并返回 expression 的值。如果 expression 被省略，
            或在函数内没有 return 语句被执行，则把值 undefined 赋给调用当前函数的表达式。
        </div>
        </div>

        <script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
        <script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

        <script>
            // 以下为常见配置属性的默认值
            // {
            //  controls: true, // 是否在右下角展示控制条
            //  progress: true, // 是否显示演示的进度条
            //  slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
            //  history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
            //  keyboard: true, // 是否启用键盘快捷键来导航
            //  overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
            //  center: true, // 是否将幻灯片垂直居中
            //  touch: true, // 是否在触屏设备上启用触摸滑动切换
            //  loop: false, // 是否循环演示
            //  rtl: false, // 是否将演示的方向变成RTL，即从右往左
            //  fragments: true, // 全局开启和关闭碎片。
            //  autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
            //  transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
            //  transitionSpeed: 'default', // 过渡速度，default/fast/slow
            //  mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
            // }

            // 初始化幻灯片
            Reveal.initialize({
                //        history: true,
                transition: 'default',
                transitionSpeed: 'slow',
                dependencies: [{
                        src: '../plugin/markdown/marked.js'
                    },
                    {
                        src: '../plugin/markdown/markdown.js'
                    },
                    {
                        src: '../plugin/notes/notes.js',
                        async: true
                    },
                    {
                        src: '../plugin/highlight/highlight.js',
                        async: true,
                        callback: function () {
                            hljs.initHighlightingOnLoad();
                        }
                    }
                ]
            });
            //    原始类型对象直接赋值不会相互影响
            //    var a = 1;
            //
            //    var b = a;
            //    b = 10;
            //    console.log(a); // 1
            ////
            //    var a = 'hello';
            //    var b = a;
            //    b = 'world';
            //    console.log(a); // hello
            //
            //    var a = true;
            //    var b = a;
            //    b = false;
            //    console.log(a);

            //数组浅复制
            //    var a = ['隔壁老王','冠希哥', '宋经理' //定义一个名为a的属猪，里面有3个值，
            //    ];
            //    var b = a;   //定义一个变量b，把a赋值给他，这样比、b和a一样了
            //    b[2] = '冲冲老师'; //然后把b的第三个值等于冲冲老师
            //    console.log(a)//那么现在打印a 是什么结果呢
            //
            //    var arr = ["One","Two","Three"];   //数组的深复制，slice方法
            //    var arrtoo = arr.slice(1);
            //    arrtoo[2] = "set Map";
            //    console.log(arr);//One,Two,Three
            //    console.log(arrtoo);//One,set Map,Three

            //
            //    var arr1 = ["One","Two","Three"]; //数组的深复制，concat 方法
            //    var arrtooo = arr1.concat(111111);
            //    arrtooo[1] = "set Map To";
            //    console.log(arr1);//One,Two,Three
            //    console.log(arrtooo);//One,set Map To,Three

            //
            //    var b=[1,2,3,4,5];   //concat的链接
            //    var c=[6,7,8,9];
            //    var d =[4,4,22]
            //    console.log(b.concat(c,d))

            var a = {
                name: 'yy',
                age: 26
            }; //对象的浅拷贝哦
            var b = new Object();
            b.name = a.name;
            b.age = a.age;
            b.name = 'xx';
            console.log(a); //Object { name="yy", age=26}
            console.log(b); //Object { name="xx", age=26}

            var d = { //对象的浅拷贝哦 第一种
                name: 'd',
                oc: {
                    age: 32
                },
                oad: {
                    adds: {
                        bb: 12
                    }
                }
            };
            var deepCopy = function (source) {
                var result = {};
                for (var key in source) {
                    result[key] = typeof source[key] === 'object' ? deepCopy(source[key]) : source[key]
                }
                return result
            };

            var c = deepCopy(d);
            c.name = 'c';
            c.oc = {
                age: 49
            };
            console.log(c);
            console.log(d);


            //    var person = {    //第二种深拷贝
            //        name: 'aa',
            //        friends: ['da', 'dsa', 'gf']
            //    };
            //
            //    var aPerson = Object.create(person, {
            ////        name: {
            ////            value: "gee"
            ////        }
            //    });
            //
            //    console.log(person.name);
            //    console.log(aPerson.friends)

            var Chinese = {
                nation: '中国'

            }
            var Doctor = {
                career: '医生'
            }

            function extendCopy(p) {
                var c = {};
                for (var i in p) {
                    c[i] = p[i];
                }
                c.uber = p;
                return c;
            }

            var Doctor = extendCopy(Chinese);
            Doctor.career = '医生';
            console.log(Doctor); // 中国
            Chinese.birthPlaces = ['北京', '上海', '香港'];
            var Doctor = extendCopy(Chinese);
            Doctor.birthPlaces.push('厦门');
        </script>

</body>

</html>